{"Oauth2CodeController":[{"controllerClass":"com.jap.controller.admin.Oauth2CodeController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n----注：在准备开始authenticate时，这里的demo是需要对OAuthConfig先进行相关配置:客户端ID，secret和回调地址等。另外，OAuth2.0不同的授权模式选择，这里以authorization_code为例。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\n当所有检查均是正确，则进入授权Authorization阶段：<br>\r\n————此时有两个方向，<br>\r\n第一种code进行加密：callback的携带参数响应码code或者令牌access_token为空且OAuth2的授权模式是授权码code模式或者简化implicit模式，则是进行pkce授权码模式，随机生成一串字符并用URL-Safe的Base64编码处理，用作 code_verifier ，将code_verifier使用SHA256哈希，并用URL-Safe的Base64编码处理，用作code_challenge，携带ode_challenge去认证服务器，拿到Code，则下一步换取token需要携带code_verifier,进行后则响应成功，设置状态码200，并进行拼接授权地址保存进响应的data中<br>\r\n第二种常规授权模式：<br>\r\n<li>判断授权类型是code模式，进入getAccessTokenOfAuthorizationCodeMode ，先拿到参数code再凭code拿到token</li>\r\n<li>由token去得到资源服务器的用户信息</li>\r\n<br>\r\n用户信息拿到，登录成功，设置响应码200，并把该用户存储到UserStore。","handler":"com.jap.controller.admin.Oauth2CodeController.renderAuth","httpMethod":"GET","id":"com.jap.controller.admin.Oauth2CodeController.renderAuth","module":"Oauth2CodeController","params":[{"bindName":"oauth2Strategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2CodeController.oauth2Strategy","headerVariable":false,"httpMethod":"GET","name":"oauth2Strategy[Q]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"Oauth2Strategy"}],"path":"/oauth/code","pathHtml":"/oauth/code","port":8093,"scheme":"HTTP","xid":"GETcom_jap_controller_admin_Oauth2CodeController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2CodeController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n----注：在准备开始authenticate时，这里的demo是需要对OAuthConfig先进行相关配置:客户端ID，secret和回调地址等。另外，OAuth2.0不同的授权模式选择，这里以authorization_code为例。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\n当所有检查均是正确，则进入授权Authorization阶段：<br>\r\n————此时有两个方向，<br>\r\n第一种code进行加密：callback的携带参数响应码code或者令牌access_token为空且OAuth2的授权模式是授权码code模式或者简化implicit模式，则是进行pkce授权码模式，随机生成一串字符并用URL-Safe的Base64编码处理，用作 code_verifier ，将code_verifier使用SHA256哈希，并用URL-Safe的Base64编码处理，用作code_challenge，携带ode_challenge去认证服务器，拿到Code，则下一步换取token需要携带code_verifier,进行后则响应成功，设置状态码200，并进行拼接授权地址保存进响应的data中<br>\r\n第二种常规授权模式：<br>\r\n<li>判断授权类型是code模式，进入getAccessTokenOfAuthorizationCodeMode ，先拿到参数code再凭code拿到token</li>\r\n<li>由token去得到资源服务器的用户信息</li>\r\n<br>\r\n用户信息拿到，登录成功，设置响应码200，并把该用户存储到UserStore。","handler":"com.jap.controller.admin.Oauth2CodeController.renderAuth","httpMethod":"POST","id":"com.jap.controller.admin.Oauth2CodeController.renderAuth","module":"Oauth2CodeController","params":[{"bindName":"oauth2Strategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2CodeController.oauth2Strategy","headerVariable":false,"httpMethod":"POST","name":"oauth2Strategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"Oauth2Strategy"}],"path":"/oauth/code","pathHtml":"/oauth/code","port":8093,"scheme":"HTTP","xid":"POSTcom_jap_controller_admin_Oauth2CodeController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2CodeController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n----注：在准备开始authenticate时，这里的demo是需要对OAuthConfig先进行相关配置:客户端ID，secret和回调地址等。另外，OAuth2.0不同的授权模式选择，这里以authorization_code为例。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\n当所有检查均是正确，则进入授权Authorization阶段：<br>\r\n————此时有两个方向，<br>\r\n第一种code进行加密：callback的携带参数响应码code或者令牌access_token为空且OAuth2的授权模式是授权码code模式或者简化implicit模式，则是进行pkce授权码模式，随机生成一串字符并用URL-Safe的Base64编码处理，用作 code_verifier ，将code_verifier使用SHA256哈希，并用URL-Safe的Base64编码处理，用作code_challenge，携带ode_challenge去认证服务器，拿到Code，则下一步换取token需要携带code_verifier,进行后则响应成功，设置状态码200，并进行拼接授权地址保存进响应的data中<br>\r\n第二种常规授权模式：<br>\r\n<li>判断授权类型是code模式，进入getAccessTokenOfAuthorizationCodeMode ，先拿到参数code再凭code拿到token</li>\r\n<li>由token去得到资源服务器的用户信息</li>\r\n<br>\r\n用户信息拿到，登录成功，设置响应码200，并把该用户存储到UserStore。","handler":"com.jap.controller.admin.Oauth2CodeController.renderAuth","httpMethod":"DELETE","id":"com.jap.controller.admin.Oauth2CodeController.renderAuth","module":"Oauth2CodeController","params":[{"bindName":"oauth2Strategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2CodeController.oauth2Strategy","headerVariable":false,"httpMethod":"DELETE","name":"oauth2Strategy","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"Oauth2Strategy"}],"path":"/oauth/code","pathHtml":"/oauth/code","port":8093,"scheme":"HTTP","xid":"DELETEcom_jap_controller_admin_Oauth2CodeController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2CodeController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n----注：在准备开始authenticate时，这里的demo是需要对OAuthConfig先进行相关配置:客户端ID，secret和回调地址等。另外，OAuth2.0不同的授权模式选择，这里以authorization_code为例。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\n当所有检查均是正确，则进入授权Authorization阶段：<br>\r\n————此时有两个方向，<br>\r\n第一种code进行加密：callback的携带参数响应码code或者令牌access_token为空且OAuth2的授权模式是授权码code模式或者简化implicit模式，则是进行pkce授权码模式，随机生成一串字符并用URL-Safe的Base64编码处理，用作 code_verifier ，将code_verifier使用SHA256哈希，并用URL-Safe的Base64编码处理，用作code_challenge，携带ode_challenge去认证服务器，拿到Code，则下一步换取token需要携带code_verifier,进行后则响应成功，设置状态码200，并进行拼接授权地址保存进响应的data中<br>\r\n第二种常规授权模式：<br>\r\n<li>判断授权类型是code模式，进入getAccessTokenOfAuthorizationCodeMode ，先拿到参数code再凭code拿到token</li>\r\n<li>由token去得到资源服务器的用户信息</li>\r\n<br>\r\n用户信息拿到，登录成功，设置响应码200，并把该用户存储到UserStore。","handler":"com.jap.controller.admin.Oauth2CodeController.renderAuth","httpMethod":"PUT","id":"com.jap.controller.admin.Oauth2CodeController.renderAuth","module":"Oauth2CodeController","params":[{"bindName":"oauth2Strategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2CodeController.oauth2Strategy","headerVariable":false,"httpMethod":"PUT","name":"oauth2Strategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"Oauth2Strategy"}],"path":"/oauth/code","pathHtml":"/oauth/code","port":8093,"scheme":"HTTP","xid":"PUTcom_jap_controller_admin_Oauth2CodeController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2CodeController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n----注：在准备开始authenticate时，这里的demo是需要对OAuthConfig先进行相关配置:客户端ID，secret和回调地址等。另外，OAuth2.0不同的授权模式选择，这里以authorization_code为例。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\n当所有检查均是正确，则进入授权Authorization阶段：<br>\r\n————此时有两个方向，<br>\r\n第一种code进行加密：callback的携带参数响应码code或者令牌access_token为空且OAuth2的授权模式是授权码code模式或者简化implicit模式，则是进行pkce授权码模式，随机生成一串字符并用URL-Safe的Base64编码处理，用作 code_verifier ，将code_verifier使用SHA256哈希，并用URL-Safe的Base64编码处理，用作code_challenge，携带ode_challenge去认证服务器，拿到Code，则下一步换取token需要携带code_verifier,进行后则响应成功，设置状态码200，并进行拼接授权地址保存进响应的data中<br>\r\n第二种常规授权模式：<br>\r\n<li>判断授权类型是code模式，进入getAccessTokenOfAuthorizationCodeMode ，先拿到参数code再凭code拿到token</li>\r\n<li>由token去得到资源服务器的用户信息</li>\r\n<br>\r\n用户信息拿到，登录成功，设置响应码200，并把该用户存储到UserStore。","handler":"com.jap.controller.admin.Oauth2CodeController.renderAuth","httpMethod":"PATCH","id":"com.jap.controller.admin.Oauth2CodeController.renderAuth","module":"Oauth2CodeController","params":[{"bindName":"oauth2Strategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2CodeController.oauth2Strategy","headerVariable":false,"httpMethod":"PATCH","name":"oauth2Strategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"Oauth2Strategy"}],"path":"/oauth/code","pathHtml":"/oauth/code","port":8093,"scheme":"HTTP","xid":"PATCHcom_jap_controller_admin_Oauth2CodeController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2CodeController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n----注：在准备开始authenticate时，这里的demo是需要对OAuthConfig先进行相关配置:客户端ID，secret和回调地址等。另外，OAuth2.0不同的授权模式选择，这里以authorization_code为例。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\n当所有检查均是正确，则进入授权Authorization阶段：<br>\r\n————此时有两个方向，<br>\r\n第一种code进行加密：callback的携带参数响应码code或者令牌access_token为空且OAuth2的授权模式是授权码code模式或者简化implicit模式，则是进行pkce授权码模式，随机生成一串字符并用URL-Safe的Base64编码处理，用作 code_verifier ，将code_verifier使用SHA256哈希，并用URL-Safe的Base64编码处理，用作code_challenge，携带ode_challenge去认证服务器，拿到Code，则下一步换取token需要携带code_verifier,进行后则响应成功，设置状态码200，并进行拼接授权地址保存进响应的data中<br>\r\n第二种常规授权模式：<br>\r\n<li>判断授权类型是code模式，进入getAccessTokenOfAuthorizationCodeMode ，先拿到参数code再凭code拿到token</li>\r\n<li>由token去得到资源服务器的用户信息</li>\r\n<br>\r\n用户信息拿到，登录成功，设置响应码200，并把该用户存储到UserStore。","handler":"com.jap.controller.admin.Oauth2CodeController.renderAuth","httpMethod":"GET","id":"com.jap.controller.admin.Oauth2CodeController.renderAuth","module":"Oauth2CodeController","params":[{"bindName":"oauth2Strategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2CodeController.oauth2Strategy","headerVariable":false,"httpMethod":"GET","name":"oauth2Strategy[Q]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"Oauth2Strategy"}],"path":"/oauth/code/getData","pathHtml":"/oauth/code/getData","port":8093,"scheme":"HTTP","xid":"GETcom_jap_controller_admin_Oauth2CodeController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2CodeController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n----注：在准备开始authenticate时，这里的demo是需要对OAuthConfig先进行相关配置:客户端ID，secret和回调地址等。另外，OAuth2.0不同的授权模式选择，这里以authorization_code为例。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\n当所有检查均是正确，则进入授权Authorization阶段：<br>\r\n————此时有两个方向，<br>\r\n第一种code进行加密：callback的携带参数响应码code或者令牌access_token为空且OAuth2的授权模式是授权码code模式或者简化implicit模式，则是进行pkce授权码模式，随机生成一串字符并用URL-Safe的Base64编码处理，用作 code_verifier ，将code_verifier使用SHA256哈希，并用URL-Safe的Base64编码处理，用作code_challenge，携带ode_challenge去认证服务器，拿到Code，则下一步换取token需要携带code_verifier,进行后则响应成功，设置状态码200，并进行拼接授权地址保存进响应的data中<br>\r\n第二种常规授权模式：<br>\r\n<li>判断授权类型是code模式，进入getAccessTokenOfAuthorizationCodeMode ，先拿到参数code再凭code拿到token</li>\r\n<li>由token去得到资源服务器的用户信息</li>\r\n<br>\r\n用户信息拿到，登录成功，设置响应码200，并把该用户存储到UserStore。","handler":"com.jap.controller.admin.Oauth2CodeController.renderAuth","httpMethod":"POST","id":"com.jap.controller.admin.Oauth2CodeController.renderAuth","module":"Oauth2CodeController","params":[{"bindName":"oauth2Strategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2CodeController.oauth2Strategy","headerVariable":false,"httpMethod":"POST","name":"oauth2Strategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"Oauth2Strategy"}],"path":"/oauth/code/getData","pathHtml":"/oauth/code/getData","port":8093,"scheme":"HTTP","xid":"POSTcom_jap_controller_admin_Oauth2CodeController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2CodeController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n----注：在准备开始authenticate时，这里的demo是需要对OAuthConfig先进行相关配置:客户端ID，secret和回调地址等。另外，OAuth2.0不同的授权模式选择，这里以authorization_code为例。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\n当所有检查均是正确，则进入授权Authorization阶段：<br>\r\n————此时有两个方向，<br>\r\n第一种code进行加密：callback的携带参数响应码code或者令牌access_token为空且OAuth2的授权模式是授权码code模式或者简化implicit模式，则是进行pkce授权码模式，随机生成一串字符并用URL-Safe的Base64编码处理，用作 code_verifier ，将code_verifier使用SHA256哈希，并用URL-Safe的Base64编码处理，用作code_challenge，携带ode_challenge去认证服务器，拿到Code，则下一步换取token需要携带code_verifier,进行后则响应成功，设置状态码200，并进行拼接授权地址保存进响应的data中<br>\r\n第二种常规授权模式：<br>\r\n<li>判断授权类型是code模式，进入getAccessTokenOfAuthorizationCodeMode ，先拿到参数code再凭code拿到token</li>\r\n<li>由token去得到资源服务器的用户信息</li>\r\n<br>\r\n用户信息拿到，登录成功，设置响应码200，并把该用户存储到UserStore。","handler":"com.jap.controller.admin.Oauth2CodeController.renderAuth","httpMethod":"DELETE","id":"com.jap.controller.admin.Oauth2CodeController.renderAuth","module":"Oauth2CodeController","params":[{"bindName":"oauth2Strategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2CodeController.oauth2Strategy","headerVariable":false,"httpMethod":"DELETE","name":"oauth2Strategy","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"Oauth2Strategy"}],"path":"/oauth/code/getData","pathHtml":"/oauth/code/getData","port":8093,"scheme":"HTTP","xid":"DELETEcom_jap_controller_admin_Oauth2CodeController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2CodeController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n----注：在准备开始authenticate时，这里的demo是需要对OAuthConfig先进行相关配置:客户端ID，secret和回调地址等。另外，OAuth2.0不同的授权模式选择，这里以authorization_code为例。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\n当所有检查均是正确，则进入授权Authorization阶段：<br>\r\n————此时有两个方向，<br>\r\n第一种code进行加密：callback的携带参数响应码code或者令牌access_token为空且OAuth2的授权模式是授权码code模式或者简化implicit模式，则是进行pkce授权码模式，随机生成一串字符并用URL-Safe的Base64编码处理，用作 code_verifier ，将code_verifier使用SHA256哈希，并用URL-Safe的Base64编码处理，用作code_challenge，携带ode_challenge去认证服务器，拿到Code，则下一步换取token需要携带code_verifier,进行后则响应成功，设置状态码200，并进行拼接授权地址保存进响应的data中<br>\r\n第二种常规授权模式：<br>\r\n<li>判断授权类型是code模式，进入getAccessTokenOfAuthorizationCodeMode ，先拿到参数code再凭code拿到token</li>\r\n<li>由token去得到资源服务器的用户信息</li>\r\n<br>\r\n用户信息拿到，登录成功，设置响应码200，并把该用户存储到UserStore。","handler":"com.jap.controller.admin.Oauth2CodeController.renderAuth","httpMethod":"PUT","id":"com.jap.controller.admin.Oauth2CodeController.renderAuth","module":"Oauth2CodeController","params":[{"bindName":"oauth2Strategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2CodeController.oauth2Strategy","headerVariable":false,"httpMethod":"PUT","name":"oauth2Strategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"Oauth2Strategy"}],"path":"/oauth/code/getData","pathHtml":"/oauth/code/getData","port":8093,"scheme":"HTTP","xid":"PUTcom_jap_controller_admin_Oauth2CodeController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2CodeController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n----注：在准备开始authenticate时，这里的demo是需要对OAuthConfig先进行相关配置:客户端ID，secret和回调地址等。另外，OAuth2.0不同的授权模式选择，这里以authorization_code为例。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\n当所有检查均是正确，则进入授权Authorization阶段：<br>\r\n————此时有两个方向，<br>\r\n第一种code进行加密：callback的携带参数响应码code或者令牌access_token为空且OAuth2的授权模式是授权码code模式或者简化implicit模式，则是进行pkce授权码模式，随机生成一串字符并用URL-Safe的Base64编码处理，用作 code_verifier ，将code_verifier使用SHA256哈希，并用URL-Safe的Base64编码处理，用作code_challenge，携带ode_challenge去认证服务器，拿到Code，则下一步换取token需要携带code_verifier,进行后则响应成功，设置状态码200，并进行拼接授权地址保存进响应的data中<br>\r\n第二种常规授权模式：<br>\r\n<li>判断授权类型是code模式，进入getAccessTokenOfAuthorizationCodeMode ，先拿到参数code再凭code拿到token</li>\r\n<li>由token去得到资源服务器的用户信息</li>\r\n<br>\r\n用户信息拿到，登录成功，设置响应码200，并把该用户存储到UserStore。","handler":"com.jap.controller.admin.Oauth2CodeController.renderAuth","httpMethod":"PATCH","id":"com.jap.controller.admin.Oauth2CodeController.renderAuth","module":"Oauth2CodeController","params":[{"bindName":"oauth2Strategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2CodeController.oauth2Strategy","headerVariable":false,"httpMethod":"PATCH","name":"oauth2Strategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"Oauth2Strategy"}],"path":"/oauth/code/getData","pathHtml":"/oauth/code/getData","port":8093,"scheme":"HTTP","xid":"PATCHcom_jap_controller_admin_Oauth2CodeController_renderAuth"}],"Oauth2PasswordController":[{"controllerClass":"com.jap.controller.admin.Oauth2PasswordController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\npassword模式，指定账号密码进行。在AccessTokenHelper类中，判断授权类型GrantType = password，调用getAccessTokenOfPasswordMode，从config中拿到相关参数，加入params集合，调用HttpUtils携带参数和URL，发出get请求，最终并返回AccessToken对象","handler":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","httpMethod":"GET","id":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","module":"Oauth2PasswordController","params":[{"bindName":"oauth2Strategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2PasswordController.oauth2Strategy","headerVariable":false,"httpMethod":"GET","name":"oauth2Strategy[Q]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"Oauth2Strategy"}],"path":"/oauth/password","pathHtml":"/oauth/password","port":8093,"scheme":"HTTP","xid":"GETcom_jap_controller_admin_Oauth2PasswordController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2PasswordController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\npassword模式，指定账号密码进行。在AccessTokenHelper类中，判断授权类型GrantType = password，调用getAccessTokenOfPasswordMode，从config中拿到相关参数，加入params集合，调用HttpUtils携带参数和URL，发出get请求，最终并返回AccessToken对象","handler":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","httpMethod":"POST","id":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","module":"Oauth2PasswordController","params":[{"bindName":"oauth2Strategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2PasswordController.oauth2Strategy","headerVariable":false,"httpMethod":"POST","name":"oauth2Strategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"Oauth2Strategy"}],"path":"/oauth/password","pathHtml":"/oauth/password","port":8093,"scheme":"HTTP","xid":"POSTcom_jap_controller_admin_Oauth2PasswordController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2PasswordController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\npassword模式，指定账号密码进行。在AccessTokenHelper类中，判断授权类型GrantType = password，调用getAccessTokenOfPasswordMode，从config中拿到相关参数，加入params集合，调用HttpUtils携带参数和URL，发出get请求，最终并返回AccessToken对象","handler":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","httpMethod":"DELETE","id":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","module":"Oauth2PasswordController","params":[{"bindName":"oauth2Strategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2PasswordController.oauth2Strategy","headerVariable":false,"httpMethod":"DELETE","name":"oauth2Strategy","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"Oauth2Strategy"}],"path":"/oauth/password","pathHtml":"/oauth/password","port":8093,"scheme":"HTTP","xid":"DELETEcom_jap_controller_admin_Oauth2PasswordController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2PasswordController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\npassword模式，指定账号密码进行。在AccessTokenHelper类中，判断授权类型GrantType = password，调用getAccessTokenOfPasswordMode，从config中拿到相关参数，加入params集合，调用HttpUtils携带参数和URL，发出get请求，最终并返回AccessToken对象","handler":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","httpMethod":"PUT","id":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","module":"Oauth2PasswordController","params":[{"bindName":"oauth2Strategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2PasswordController.oauth2Strategy","headerVariable":false,"httpMethod":"PUT","name":"oauth2Strategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"Oauth2Strategy"}],"path":"/oauth/password","pathHtml":"/oauth/password","port":8093,"scheme":"HTTP","xid":"PUTcom_jap_controller_admin_Oauth2PasswordController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2PasswordController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\npassword模式，指定账号密码进行。在AccessTokenHelper类中，判断授权类型GrantType = password，调用getAccessTokenOfPasswordMode，从config中拿到相关参数，加入params集合，调用HttpUtils携带参数和URL，发出get请求，最终并返回AccessToken对象","handler":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","httpMethod":"PATCH","id":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","module":"Oauth2PasswordController","params":[{"bindName":"oauth2Strategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2PasswordController.oauth2Strategy","headerVariable":false,"httpMethod":"PATCH","name":"oauth2Strategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"Oauth2Strategy"}],"path":"/oauth/password","pathHtml":"/oauth/password","port":8093,"scheme":"HTTP","xid":"PATCHcom_jap_controller_admin_Oauth2PasswordController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2PasswordController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\npassword模式，指定账号密码进行。在AccessTokenHelper类中，判断授权类型GrantType = password，调用getAccessTokenOfPasswordMode，从config中拿到相关参数，加入params集合，调用HttpUtils携带参数和URL，发出get请求，最终并返回AccessToken对象","handler":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","httpMethod":"GET","id":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","module":"Oauth2PasswordController","params":[{"bindName":"oauth2Strategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2PasswordController.oauth2Strategy","headerVariable":false,"httpMethod":"GET","name":"oauth2Strategy[Q]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"Oauth2Strategy"}],"path":"/oauth/password/getData","pathHtml":"/oauth/password/getData","port":8093,"scheme":"HTTP","xid":"GETcom_jap_controller_admin_Oauth2PasswordController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2PasswordController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\npassword模式，指定账号密码进行。在AccessTokenHelper类中，判断授权类型GrantType = password，调用getAccessTokenOfPasswordMode，从config中拿到相关参数，加入params集合，调用HttpUtils携带参数和URL，发出get请求，最终并返回AccessToken对象","handler":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","httpMethod":"POST","id":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","module":"Oauth2PasswordController","params":[{"bindName":"oauth2Strategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2PasswordController.oauth2Strategy","headerVariable":false,"httpMethod":"POST","name":"oauth2Strategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"Oauth2Strategy"}],"path":"/oauth/password/getData","pathHtml":"/oauth/password/getData","port":8093,"scheme":"HTTP","xid":"POSTcom_jap_controller_admin_Oauth2PasswordController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2PasswordController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\npassword模式，指定账号密码进行。在AccessTokenHelper类中，判断授权类型GrantType = password，调用getAccessTokenOfPasswordMode，从config中拿到相关参数，加入params集合，调用HttpUtils携带参数和URL，发出get请求，最终并返回AccessToken对象","handler":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","httpMethod":"DELETE","id":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","module":"Oauth2PasswordController","params":[{"bindName":"oauth2Strategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2PasswordController.oauth2Strategy","headerVariable":false,"httpMethod":"DELETE","name":"oauth2Strategy","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"Oauth2Strategy"}],"path":"/oauth/password/getData","pathHtml":"/oauth/password/getData","port":8093,"scheme":"HTTP","xid":"DELETEcom_jap_controller_admin_Oauth2PasswordController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2PasswordController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\npassword模式，指定账号密码进行。在AccessTokenHelper类中，判断授权类型GrantType = password，调用getAccessTokenOfPasswordMode，从config中拿到相关参数，加入params集合，调用HttpUtils携带参数和URL，发出get请求，最终并返回AccessToken对象","handler":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","httpMethod":"PUT","id":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","module":"Oauth2PasswordController","params":[{"bindName":"oauth2Strategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2PasswordController.oauth2Strategy","headerVariable":false,"httpMethod":"PUT","name":"oauth2Strategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"Oauth2Strategy"}],"path":"/oauth/password/getData","pathHtml":"/oauth/password/getData","port":8093,"scheme":"HTTP","xid":"PUTcom_jap_controller_admin_Oauth2PasswordController_renderAuth"},{"controllerClass":"com.jap.controller.admin.Oauth2PasswordController","description":"准备策略：<br>\r\n----Oauth2Strategy：选择oauth验证策略，加入已经实现该策略验证方式的service具体类，这里是JapOauth2UserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的JapLocalCache缓存：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存,<br>\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n<br>\r\n验证授权：<br>\r\n----oauth策略的验证方法是Oauth2Strategy的authenticate实现，首先，第一个参数也就是上一步配置的OAuthConfig，authenticate中先需要进行一些列的check检查：\r\n<li>1.checkOauthCallbackRequest：检查请求地址中有无错误的参数pram，若存在，则抛出apOauth2Exception异常，反之进行下一步操作</li>\r\n<li>2.checkSession：检查session中是否已经保存过该用户，也就是判断之前用户已经登录并验证成功时保存在UserStore中，若存在，则把已经存进UserStore()的用户拿出，直接响应success，设置状态码200，反之进行下一步</li>\r\n<li>3.checkAuthenticateConfig：检查第一个参数OAuthConfig的基类AuthenticateConfig配置是否为空等，若存在，抛出JapException:MISS_AUTHENTICATE_CONFIG异常等，反之，进行下一步</li>\r\n<li>4.checkOauthConfig：进一步检查参数OAuthConfig对象的相关配置是否正确，如授权类型GrantType等，配置不正确，则抛出相关异常，全部配置正常，则进行下一步操作</li>\r\n<br>\r\npassword模式，指定账号密码进行。在AccessTokenHelper类中，判断授权类型GrantType = password，调用getAccessTokenOfPasswordMode，从config中拿到相关参数，加入params集合，调用HttpUtils携带参数和URL，发出get请求，最终并返回AccessToken对象","handler":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","httpMethod":"PATCH","id":"com.jap.controller.admin.Oauth2PasswordController.renderAuth","module":"Oauth2PasswordController","params":[{"bindName":"oauth2Strategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.Oauth2PasswordController.oauth2Strategy","headerVariable":false,"httpMethod":"PATCH","name":"oauth2Strategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"Oauth2Strategy"}],"path":"/oauth/password/getData","pathHtml":"/oauth/password/getData","port":8093,"scheme":"HTTP","xid":"PATCHcom_jap_controller_admin_Oauth2PasswordController_renderAuth"}],"OidcController":[{"controllerClass":"com.jap.controller.admin.OidcController","description":"com.jap.controller.admin.OidcController.renderAuth","handler":"com.jap.controller.admin.OidcController.renderAuth","httpMethod":"GET","id":"com.jap.controller.admin.OidcController.renderAuth","module":"OidcController","params":[{"bindName":"oidcStrategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.OidcController.oidcStrategy","headerVariable":false,"httpMethod":"GET","name":"oidcStrategy[Q]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"OidcStrategy"}],"path":"/oidc/auth","pathHtml":"/oidc/auth","port":8093,"scheme":"HTTP","xid":"GETcom_jap_controller_admin_OidcController_renderAuth"},{"controllerClass":"com.jap.controller.admin.OidcController","description":"com.jap.controller.admin.OidcController.renderAuth","handler":"com.jap.controller.admin.OidcController.renderAuth","httpMethod":"POST","id":"com.jap.controller.admin.OidcController.renderAuth","module":"OidcController","params":[{"bindName":"oidcStrategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.OidcController.oidcStrategy","headerVariable":false,"httpMethod":"POST","name":"oidcStrategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"OidcStrategy"}],"path":"/oidc/auth","pathHtml":"/oidc/auth","port":8093,"scheme":"HTTP","xid":"POSTcom_jap_controller_admin_OidcController_renderAuth"},{"controllerClass":"com.jap.controller.admin.OidcController","description":"com.jap.controller.admin.OidcController.renderAuth","handler":"com.jap.controller.admin.OidcController.renderAuth","httpMethod":"DELETE","id":"com.jap.controller.admin.OidcController.renderAuth","module":"OidcController","params":[{"bindName":"oidcStrategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.OidcController.oidcStrategy","headerVariable":false,"httpMethod":"DELETE","name":"oidcStrategy","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"OidcStrategy"}],"path":"/oidc/auth","pathHtml":"/oidc/auth","port":8093,"scheme":"HTTP","xid":"DELETEcom_jap_controller_admin_OidcController_renderAuth"},{"controllerClass":"com.jap.controller.admin.OidcController","description":"com.jap.controller.admin.OidcController.renderAuth","handler":"com.jap.controller.admin.OidcController.renderAuth","httpMethod":"PUT","id":"com.jap.controller.admin.OidcController.renderAuth","module":"OidcController","params":[{"bindName":"oidcStrategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.OidcController.oidcStrategy","headerVariable":false,"httpMethod":"PUT","name":"oidcStrategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"OidcStrategy"}],"path":"/oidc/auth","pathHtml":"/oidc/auth","port":8093,"scheme":"HTTP","xid":"PUTcom_jap_controller_admin_OidcController_renderAuth"},{"controllerClass":"com.jap.controller.admin.OidcController","description":"com.jap.controller.admin.OidcController.renderAuth","handler":"com.jap.controller.admin.OidcController.renderAuth","httpMethod":"PATCH","id":"com.jap.controller.admin.OidcController.renderAuth","module":"OidcController","params":[{"bindName":"oidcStrategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.OidcController.oidcStrategy","headerVariable":false,"httpMethod":"PATCH","name":"oidcStrategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"OidcStrategy"}],"path":"/oidc/auth","pathHtml":"/oidc/auth","port":8093,"scheme":"HTTP","xid":"PATCHcom_jap_controller_admin_OidcController_renderAuth"},{"controllerClass":"com.jap.controller.admin.OidcController","description":"com.jap.controller.admin.OidcController.renderAuth","handler":"com.jap.controller.admin.OidcController.renderAuth","httpMethod":"GET","id":"com.jap.controller.admin.OidcController.renderAuth","module":"OidcController","params":[{"bindName":"oidcStrategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.OidcController.oidcStrategy","headerVariable":false,"httpMethod":"GET","name":"oidcStrategy[Q]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"OidcStrategy"}],"path":"/oidc/getData","pathHtml":"/oidc/getData","port":8093,"scheme":"HTTP","xid":"GETcom_jap_controller_admin_OidcController_renderAuth"},{"controllerClass":"com.jap.controller.admin.OidcController","description":"com.jap.controller.admin.OidcController.renderAuth","handler":"com.jap.controller.admin.OidcController.renderAuth","httpMethod":"POST","id":"com.jap.controller.admin.OidcController.renderAuth","module":"OidcController","params":[{"bindName":"oidcStrategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.OidcController.oidcStrategy","headerVariable":false,"httpMethod":"POST","name":"oidcStrategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"OidcStrategy"}],"path":"/oidc/getData","pathHtml":"/oidc/getData","port":8093,"scheme":"HTTP","xid":"POSTcom_jap_controller_admin_OidcController_renderAuth"},{"controllerClass":"com.jap.controller.admin.OidcController","description":"com.jap.controller.admin.OidcController.renderAuth","handler":"com.jap.controller.admin.OidcController.renderAuth","httpMethod":"DELETE","id":"com.jap.controller.admin.OidcController.renderAuth","module":"OidcController","params":[{"bindName":"oidcStrategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.OidcController.oidcStrategy","headerVariable":false,"httpMethod":"DELETE","name":"oidcStrategy","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"OidcStrategy"}],"path":"/oidc/getData","pathHtml":"/oidc/getData","port":8093,"scheme":"HTTP","xid":"DELETEcom_jap_controller_admin_OidcController_renderAuth"},{"controllerClass":"com.jap.controller.admin.OidcController","description":"com.jap.controller.admin.OidcController.renderAuth","handler":"com.jap.controller.admin.OidcController.renderAuth","httpMethod":"PUT","id":"com.jap.controller.admin.OidcController.renderAuth","module":"OidcController","params":[{"bindName":"oidcStrategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.OidcController.oidcStrategy","headerVariable":false,"httpMethod":"PUT","name":"oidcStrategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"OidcStrategy"}],"path":"/oidc/getData","pathHtml":"/oidc/getData","port":8093,"scheme":"HTTP","xid":"PUTcom_jap_controller_admin_OidcController_renderAuth"},{"controllerClass":"com.jap.controller.admin.OidcController","description":"com.jap.controller.admin.OidcController.renderAuth","handler":"com.jap.controller.admin.OidcController.renderAuth","httpMethod":"PATCH","id":"com.jap.controller.admin.OidcController.renderAuth","module":"OidcController","params":[{"bindName":"oidcStrategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.OidcController.oidcStrategy","headerVariable":false,"httpMethod":"PATCH","name":"oidcStrategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"OidcStrategy"}],"path":"/oidc/getData","pathHtml":"/oidc/getData","port":8093,"scheme":"HTTP","xid":"PATCHcom_jap_controller_admin_OidcController_renderAuth"}],"SimpleController":[{"controllerClass":"com.jap.controller.admin.SimpleController","description":"准备策略：<br>\r\n----SimpleStrategy：选择simple验证策略，加入已经实现该策略验证方式的service具体类，这里是JapSimpleUserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的缓存JapLocalCache：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存，\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n----注：在准备开始authenticate时，这里的demo是对simpleConfig保持默认的配置。<br>\r\n验证授权：<br>\r\n----simple策略的验证方法是SimpleStrategy的authenticate实现，首先是参数SimpleConfig验证配置的初始化，经过一系列配置检查后，检查checkSessionAndCookie中有无此时登录的用户，如果存在，则说明登录成功，设置状态码200并返回响应<br>\r\n如果不存在(说明是第一次登录)，就先去doResolveCredential：判断username和password是否同时非空，满足则封装为一个Credential并初始化该类变量，其中的rememberMe从request的getParam(\"rememberMe\")函数进行判断，1——>Credential.getrememberMe()为真，先使用使用service具体类的getByName方法，未查到该用户账号，响应用户不存在NOT_EXIST_USER，否则继续使用validPassword，判断密码是否有效,\r\n密码也正确，此时两个方向判断：先判断有没有实现rememberMe ——有——>测需要先addCookie，再跳转loginSuccess，设置状态码200，否则，直接跳转loginSuccess。","handler":"com.jap.controller.admin.SimpleController.get","httpMethod":"POST","id":"com.jap.controller.admin.SimpleController.get","module":"SimpleController","params":[],"path":"/simple/logined","pathHtml":"/simple/logined","port":8093,"scheme":"HTTP","xid":"POSTcom_jap_controller_admin_SimpleController_get"},{"controllerClass":"com.jap.controller.admin.SimpleController","description":"com.jap.controller.admin.SimpleController.toLogin","handler":"com.jap.controller.admin.SimpleController.toLogin","httpMethod":"GET","id":"com.jap.controller.admin.SimpleController.toLogin","module":"SimpleController","params":[],"path":"/simple/test","pathHtml":"/simple/test","port":8093,"scheme":"HTTP","xid":"GETcom_jap_controller_admin_SimpleController_toLogin"}],"ThirdLoginController":[{"controllerClass":"com.jap.controller.admin.ThirdLoginController","description":"准备策略：<br>\r\n----SocialStrategy：选择第三方应用 social验证策略，<a href=\"https://justauth.plus/quickstart/jap-social.html#%E6%B5%8B%E8%AF%95%E7%99%BB%E5%BD%95\">jap-social 是为了方便快速的集成第三方登录而添加的增强包</a>加入已经实现该策略验证方式的service具体类，这里是JapSocialUserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的缓存JapLocalCache：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存，\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n----注：在准备开始authenticate时，这里的demo是对SocialConfig保持默认的配置。<br>\r\n验证授权：<br>\r\n----social策略的验证方法是SocialStrategy的authenticate实现(参数是SocialConfig的上转型、HttpServletRequest、HttpServletResponse)，首先是先进行参数SocialConfig验证配置的初始化，配置检查，检查checkSessionAndCookie中有无此时登录的用户，如果存在，则说明登录成功（非首次登录），设置状态码200并返回响应<br>\r\n如果不存在(说明是第一次登录)，就先去调用getAuthRequest拿到AuthRequest对象（授权、登录接口）—--—实现方式————>，以SocialConfig对象的上转型AuthenticateConfig为参数，进行checkAuthenticateConfig检查配置完成且其子类socialConfig.getJustAuthConfig()非空后，<br>\r\n以第三方应用Platform平台（不能为空），socialConfig, authConfig，authStateCache为参数,去拿并返回AuthRequest实例（后面去授权、登录需要调用该实例接口）<br>\r\n参数准备：<br>\r\n<li>socialConfig：authenticate函数第一个参数转为子类SocialConfig对象</li>\r\n<li>source：从socialConfig拿到第三方平台名称</li>\r\n<li>authCallback（存有基本的授权参数）：把HttpServletRequest的所有参数转为Map集合（参数若为null，则new一个AuthCallback对象，否则遍历集合，进一步存入JSON对象中，由JSON的toJavaObject，拿到AuthCallback），</li>\r\n<br>\r\n判断是否已经回调isCallback(String source, AuthCallback authCallback) ：若默认第三方应用名字与参数source相同且authCallback的token非空，则返回TRUE，否则去authCallback拿到code值（这里需要特别判断一下授权码code是否是来源于ALIPAY或者HUAWEI），若code为空，返回TRUE<br>\r\n<li>isCallback返回值为FALSE：调用authRequest.authorize(socialConfig.getState())，返回JapResponse.success(url)，授权成功的响应，同意授权后URL中会带有生成的授权码code，再调用一次回调函数，进入该方法中，由code去拿到token</li>\r\n<li>isCallback返回值为TRUE：调用authRequest.login(request, response, source, authRequest, authCallback)————实现方式——---->实例化AuthResponse对象，用于存储后面通过token拿拿到用户信息的响应，由响应的用户ID和第三方平台名字为参数调用japUserService的getByPlatformAndUid去模拟数据库中查询用户信息，若不存在该用户则去调用japUserService的createAndGetSocialUser，都是把查询或者创建的用户存到JapUser对象中。此时已经登录成功，但需要把用户相关信息存入JapContext的UserStore（调用其接口实现，有单点登录Store和Session的Store存储）中。</li>","handler":"com.jap.controller.admin.ThirdLoginController.renderAuth","httpMethod":"GET","id":"com.jap.controller.admin.ThirdLoginController.renderAuth","module":"ThirdLoginController","params":[{"bindName":"socialStrategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.ThirdLoginController.socialStrategy","headerVariable":false,"httpMethod":"GET","name":"socialStrategy[Q]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"SocialStrategy"}],"path":"/social/auth","pathHtml":"/social/auth","port":8093,"scheme":"HTTP","xid":"GETcom_jap_controller_admin_ThirdLoginController_renderAuth"},{"controllerClass":"com.jap.controller.admin.ThirdLoginController","description":"准备策略：<br>\r\n----SocialStrategy：选择第三方应用 social验证策略，<a href=\"https://justauth.plus/quickstart/jap-social.html#%E6%B5%8B%E8%AF%95%E7%99%BB%E5%BD%95\">jap-social 是为了方便快速的集成第三方登录而添加的增强包</a>加入已经实现该策略验证方式的service具体类，这里是JapSocialUserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的缓存JapLocalCache：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存，\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n----注：在准备开始authenticate时，这里的demo是对SocialConfig保持默认的配置。<br>\r\n验证授权：<br>\r\n----social策略的验证方法是SocialStrategy的authenticate实现(参数是SocialConfig的上转型、HttpServletRequest、HttpServletResponse)，首先是先进行参数SocialConfig验证配置的初始化，配置检查，检查checkSessionAndCookie中有无此时登录的用户，如果存在，则说明登录成功（非首次登录），设置状态码200并返回响应<br>\r\n如果不存在(说明是第一次登录)，就先去调用getAuthRequest拿到AuthRequest对象（授权、登录接口）—--—实现方式————>，以SocialConfig对象的上转型AuthenticateConfig为参数，进行checkAuthenticateConfig检查配置完成且其子类socialConfig.getJustAuthConfig()非空后，<br>\r\n以第三方应用Platform平台（不能为空），socialConfig, authConfig，authStateCache为参数,去拿并返回AuthRequest实例（后面去授权、登录需要调用该实例接口）<br>\r\n参数准备：<br>\r\n<li>socialConfig：authenticate函数第一个参数转为子类SocialConfig对象</li>\r\n<li>source：从socialConfig拿到第三方平台名称</li>\r\n<li>authCallback（存有基本的授权参数）：把HttpServletRequest的所有参数转为Map集合（参数若为null，则new一个AuthCallback对象，否则遍历集合，进一步存入JSON对象中，由JSON的toJavaObject，拿到AuthCallback），</li>\r\n<br>\r\n判断是否已经回调isCallback(String source, AuthCallback authCallback) ：若默认第三方应用名字与参数source相同且authCallback的token非空，则返回TRUE，否则去authCallback拿到code值（这里需要特别判断一下授权码code是否是来源于ALIPAY或者HUAWEI），若code为空，返回TRUE<br>\r\n<li>isCallback返回值为FALSE：调用authRequest.authorize(socialConfig.getState())，返回JapResponse.success(url)，授权成功的响应，同意授权后URL中会带有生成的授权码code，再调用一次回调函数，进入该方法中，由code去拿到token</li>\r\n<li>isCallback返回值为TRUE：调用authRequest.login(request, response, source, authRequest, authCallback)————实现方式——---->实例化AuthResponse对象，用于存储后面通过token拿拿到用户信息的响应，由响应的用户ID和第三方平台名字为参数调用japUserService的getByPlatformAndUid去模拟数据库中查询用户信息，若不存在该用户则去调用japUserService的createAndGetSocialUser，都是把查询或者创建的用户存到JapUser对象中。此时已经登录成功，但需要把用户相关信息存入JapContext的UserStore（调用其接口实现，有单点登录Store和Session的Store存储）中。</li>","handler":"com.jap.controller.admin.ThirdLoginController.renderAuth","httpMethod":"POST","id":"com.jap.controller.admin.ThirdLoginController.renderAuth","module":"ThirdLoginController","params":[{"bindName":"socialStrategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.ThirdLoginController.socialStrategy","headerVariable":false,"httpMethod":"POST","name":"socialStrategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"SocialStrategy"}],"path":"/social/auth","pathHtml":"/social/auth","port":8093,"scheme":"HTTP","xid":"POSTcom_jap_controller_admin_ThirdLoginController_renderAuth"},{"controllerClass":"com.jap.controller.admin.ThirdLoginController","description":"准备策略：<br>\r\n----SocialStrategy：选择第三方应用 social验证策略，<a href=\"https://justauth.plus/quickstart/jap-social.html#%E6%B5%8B%E8%AF%95%E7%99%BB%E5%BD%95\">jap-social 是为了方便快速的集成第三方登录而添加的增强包</a>加入已经实现该策略验证方式的service具体类，这里是JapSocialUserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的缓存JapLocalCache：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存，\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n----注：在准备开始authenticate时，这里的demo是对SocialConfig保持默认的配置。<br>\r\n验证授权：<br>\r\n----social策略的验证方法是SocialStrategy的authenticate实现(参数是SocialConfig的上转型、HttpServletRequest、HttpServletResponse)，首先是先进行参数SocialConfig验证配置的初始化，配置检查，检查checkSessionAndCookie中有无此时登录的用户，如果存在，则说明登录成功（非首次登录），设置状态码200并返回响应<br>\r\n如果不存在(说明是第一次登录)，就先去调用getAuthRequest拿到AuthRequest对象（授权、登录接口）—--—实现方式————>，以SocialConfig对象的上转型AuthenticateConfig为参数，进行checkAuthenticateConfig检查配置完成且其子类socialConfig.getJustAuthConfig()非空后，<br>\r\n以第三方应用Platform平台（不能为空），socialConfig, authConfig，authStateCache为参数,去拿并返回AuthRequest实例（后面去授权、登录需要调用该实例接口）<br>\r\n参数准备：<br>\r\n<li>socialConfig：authenticate函数第一个参数转为子类SocialConfig对象</li>\r\n<li>source：从socialConfig拿到第三方平台名称</li>\r\n<li>authCallback（存有基本的授权参数）：把HttpServletRequest的所有参数转为Map集合（参数若为null，则new一个AuthCallback对象，否则遍历集合，进一步存入JSON对象中，由JSON的toJavaObject，拿到AuthCallback），</li>\r\n<br>\r\n判断是否已经回调isCallback(String source, AuthCallback authCallback) ：若默认第三方应用名字与参数source相同且authCallback的token非空，则返回TRUE，否则去authCallback拿到code值（这里需要特别判断一下授权码code是否是来源于ALIPAY或者HUAWEI），若code为空，返回TRUE<br>\r\n<li>isCallback返回值为FALSE：调用authRequest.authorize(socialConfig.getState())，返回JapResponse.success(url)，授权成功的响应，同意授权后URL中会带有生成的授权码code，再调用一次回调函数，进入该方法中，由code去拿到token</li>\r\n<li>isCallback返回值为TRUE：调用authRequest.login(request, response, source, authRequest, authCallback)————实现方式——---->实例化AuthResponse对象，用于存储后面通过token拿拿到用户信息的响应，由响应的用户ID和第三方平台名字为参数调用japUserService的getByPlatformAndUid去模拟数据库中查询用户信息，若不存在该用户则去调用japUserService的createAndGetSocialUser，都是把查询或者创建的用户存到JapUser对象中。此时已经登录成功，但需要把用户相关信息存入JapContext的UserStore（调用其接口实现，有单点登录Store和Session的Store存储）中。</li>","handler":"com.jap.controller.admin.ThirdLoginController.renderAuth","httpMethod":"DELETE","id":"com.jap.controller.admin.ThirdLoginController.renderAuth","module":"ThirdLoginController","params":[{"bindName":"socialStrategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.ThirdLoginController.socialStrategy","headerVariable":false,"httpMethod":"DELETE","name":"socialStrategy","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"SocialStrategy"}],"path":"/social/auth","pathHtml":"/social/auth","port":8093,"scheme":"HTTP","xid":"DELETEcom_jap_controller_admin_ThirdLoginController_renderAuth"},{"controllerClass":"com.jap.controller.admin.ThirdLoginController","description":"准备策略：<br>\r\n----SocialStrategy：选择第三方应用 social验证策略，<a href=\"https://justauth.plus/quickstart/jap-social.html#%E6%B5%8B%E8%AF%95%E7%99%BB%E5%BD%95\">jap-social 是为了方便快速的集成第三方登录而添加的增强包</a>加入已经实现该策略验证方式的service具体类，这里是JapSocialUserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的缓存JapLocalCache：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存，\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n----注：在准备开始authenticate时，这里的demo是对SocialConfig保持默认的配置。<br>\r\n验证授权：<br>\r\n----social策略的验证方法是SocialStrategy的authenticate实现(参数是SocialConfig的上转型、HttpServletRequest、HttpServletResponse)，首先是先进行参数SocialConfig验证配置的初始化，配置检查，检查checkSessionAndCookie中有无此时登录的用户，如果存在，则说明登录成功（非首次登录），设置状态码200并返回响应<br>\r\n如果不存在(说明是第一次登录)，就先去调用getAuthRequest拿到AuthRequest对象（授权、登录接口）—--—实现方式————>，以SocialConfig对象的上转型AuthenticateConfig为参数，进行checkAuthenticateConfig检查配置完成且其子类socialConfig.getJustAuthConfig()非空后，<br>\r\n以第三方应用Platform平台（不能为空），socialConfig, authConfig，authStateCache为参数,去拿并返回AuthRequest实例（后面去授权、登录需要调用该实例接口）<br>\r\n参数准备：<br>\r\n<li>socialConfig：authenticate函数第一个参数转为子类SocialConfig对象</li>\r\n<li>source：从socialConfig拿到第三方平台名称</li>\r\n<li>authCallback（存有基本的授权参数）：把HttpServletRequest的所有参数转为Map集合（参数若为null，则new一个AuthCallback对象，否则遍历集合，进一步存入JSON对象中，由JSON的toJavaObject，拿到AuthCallback），</li>\r\n<br>\r\n判断是否已经回调isCallback(String source, AuthCallback authCallback) ：若默认第三方应用名字与参数source相同且authCallback的token非空，则返回TRUE，否则去authCallback拿到code值（这里需要特别判断一下授权码code是否是来源于ALIPAY或者HUAWEI），若code为空，返回TRUE<br>\r\n<li>isCallback返回值为FALSE：调用authRequest.authorize(socialConfig.getState())，返回JapResponse.success(url)，授权成功的响应，同意授权后URL中会带有生成的授权码code，再调用一次回调函数，进入该方法中，由code去拿到token</li>\r\n<li>isCallback返回值为TRUE：调用authRequest.login(request, response, source, authRequest, authCallback)————实现方式——---->实例化AuthResponse对象，用于存储后面通过token拿拿到用户信息的响应，由响应的用户ID和第三方平台名字为参数调用japUserService的getByPlatformAndUid去模拟数据库中查询用户信息，若不存在该用户则去调用japUserService的createAndGetSocialUser，都是把查询或者创建的用户存到JapUser对象中。此时已经登录成功，但需要把用户相关信息存入JapContext的UserStore（调用其接口实现，有单点登录Store和Session的Store存储）中。</li>","handler":"com.jap.controller.admin.ThirdLoginController.renderAuth","httpMethod":"PUT","id":"com.jap.controller.admin.ThirdLoginController.renderAuth","module":"ThirdLoginController","params":[{"bindName":"socialStrategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.ThirdLoginController.socialStrategy","headerVariable":false,"httpMethod":"PUT","name":"socialStrategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"SocialStrategy"}],"path":"/social/auth","pathHtml":"/social/auth","port":8093,"scheme":"HTTP","xid":"PUTcom_jap_controller_admin_ThirdLoginController_renderAuth"},{"controllerClass":"com.jap.controller.admin.ThirdLoginController","description":"准备策略：<br>\r\n----SocialStrategy：选择第三方应用 social验证策略，<a href=\"https://justauth.plus/quickstart/jap-social.html#%E6%B5%8B%E8%AF%95%E7%99%BB%E5%BD%95\">jap-social 是为了方便快速的集成第三方登录而添加的增强包</a>加入已经实现该策略验证方式的service具体类，这里是JapSocialUserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的缓存JapLocalCache：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存，\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n----注：在准备开始authenticate时，这里的demo是对SocialConfig保持默认的配置。<br>\r\n验证授权：<br>\r\n----social策略的验证方法是SocialStrategy的authenticate实现(参数是SocialConfig的上转型、HttpServletRequest、HttpServletResponse)，首先是先进行参数SocialConfig验证配置的初始化，配置检查，检查checkSessionAndCookie中有无此时登录的用户，如果存在，则说明登录成功（非首次登录），设置状态码200并返回响应<br>\r\n如果不存在(说明是第一次登录)，就先去调用getAuthRequest拿到AuthRequest对象（授权、登录接口）—--—实现方式————>，以SocialConfig对象的上转型AuthenticateConfig为参数，进行checkAuthenticateConfig检查配置完成且其子类socialConfig.getJustAuthConfig()非空后，<br>\r\n以第三方应用Platform平台（不能为空），socialConfig, authConfig，authStateCache为参数,去拿并返回AuthRequest实例（后面去授权、登录需要调用该实例接口）<br>\r\n参数准备：<br>\r\n<li>socialConfig：authenticate函数第一个参数转为子类SocialConfig对象</li>\r\n<li>source：从socialConfig拿到第三方平台名称</li>\r\n<li>authCallback（存有基本的授权参数）：把HttpServletRequest的所有参数转为Map集合（参数若为null，则new一个AuthCallback对象，否则遍历集合，进一步存入JSON对象中，由JSON的toJavaObject，拿到AuthCallback），</li>\r\n<br>\r\n判断是否已经回调isCallback(String source, AuthCallback authCallback) ：若默认第三方应用名字与参数source相同且authCallback的token非空，则返回TRUE，否则去authCallback拿到code值（这里需要特别判断一下授权码code是否是来源于ALIPAY或者HUAWEI），若code为空，返回TRUE<br>\r\n<li>isCallback返回值为FALSE：调用authRequest.authorize(socialConfig.getState())，返回JapResponse.success(url)，授权成功的响应，同意授权后URL中会带有生成的授权码code，再调用一次回调函数，进入该方法中，由code去拿到token</li>\r\n<li>isCallback返回值为TRUE：调用authRequest.login(request, response, source, authRequest, authCallback)————实现方式——---->实例化AuthResponse对象，用于存储后面通过token拿拿到用户信息的响应，由响应的用户ID和第三方平台名字为参数调用japUserService的getByPlatformAndUid去模拟数据库中查询用户信息，若不存在该用户则去调用japUserService的createAndGetSocialUser，都是把查询或者创建的用户存到JapUser对象中。此时已经登录成功，但需要把用户相关信息存入JapContext的UserStore（调用其接口实现，有单点登录Store和Session的Store存储）中。</li>","handler":"com.jap.controller.admin.ThirdLoginController.renderAuth","httpMethod":"PATCH","id":"com.jap.controller.admin.ThirdLoginController.renderAuth","module":"ThirdLoginController","params":[{"bindName":"socialStrategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.ThirdLoginController.socialStrategy","headerVariable":false,"httpMethod":"PATCH","name":"socialStrategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"SocialStrategy"}],"path":"/social/auth","pathHtml":"/social/auth","port":8093,"scheme":"HTTP","xid":"PATCHcom_jap_controller_admin_ThirdLoginController_renderAuth"},{"controllerClass":"com.jap.controller.admin.ThirdLoginController","description":"准备策略：<br>\r\n----SocialStrategy：选择第三方应用 social验证策略，<a href=\"https://justauth.plus/quickstart/jap-social.html#%E6%B5%8B%E8%AF%95%E7%99%BB%E5%BD%95\">jap-social 是为了方便快速的集成第三方登录而添加的增强包</a>加入已经实现该策略验证方式的service具体类，这里是JapSocialUserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的缓存JapLocalCache：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存，\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n----注：在准备开始authenticate时，这里的demo是对SocialConfig保持默认的配置。<br>\r\n验证授权：<br>\r\n----social策略的验证方法是SocialStrategy的authenticate实现(参数是SocialConfig的上转型、HttpServletRequest、HttpServletResponse)，首先是先进行参数SocialConfig验证配置的初始化，配置检查，检查checkSessionAndCookie中有无此时登录的用户，如果存在，则说明登录成功（非首次登录），设置状态码200并返回响应<br>\r\n如果不存在(说明是第一次登录)，就先去调用getAuthRequest拿到AuthRequest对象（授权、登录接口）—--—实现方式————>，以SocialConfig对象的上转型AuthenticateConfig为参数，进行checkAuthenticateConfig检查配置完成且其子类socialConfig.getJustAuthConfig()非空后，<br>\r\n以第三方应用Platform平台（不能为空），socialConfig, authConfig，authStateCache为参数,去拿并返回AuthRequest实例（后面去授权、登录需要调用该实例接口）<br>\r\n参数准备：<br>\r\n<li>socialConfig：authenticate函数第一个参数转为子类SocialConfig对象</li>\r\n<li>source：从socialConfig拿到第三方平台名称</li>\r\n<li>authCallback（存有基本的授权参数）：把HttpServletRequest的所有参数转为Map集合（参数若为null，则new一个AuthCallback对象，否则遍历集合，进一步存入JSON对象中，由JSON的toJavaObject，拿到AuthCallback），</li>\r\n<br>\r\n判断是否已经回调isCallback(String source, AuthCallback authCallback) ：若默认第三方应用名字与参数source相同且authCallback的token非空，则返回TRUE，否则去authCallback拿到code值（这里需要特别判断一下授权码code是否是来源于ALIPAY或者HUAWEI），若code为空，返回TRUE<br>\r\n<li>isCallback返回值为FALSE：调用authRequest.authorize(socialConfig.getState())，返回JapResponse.success(url)，授权成功的响应，同意授权后URL中会带有生成的授权码code，再调用一次回调函数，进入该方法中，由code去拿到token</li>\r\n<li>isCallback返回值为TRUE：调用authRequest.login(request, response, source, authRequest, authCallback)————实现方式——---->实例化AuthResponse对象，用于存储后面通过token拿拿到用户信息的响应，由响应的用户ID和第三方平台名字为参数调用japUserService的getByPlatformAndUid去模拟数据库中查询用户信息，若不存在该用户则去调用japUserService的createAndGetSocialUser，都是把查询或者创建的用户存到JapUser对象中。此时已经登录成功，但需要把用户相关信息存入JapContext的UserStore（调用其接口实现，有单点登录Store和Session的Store存储）中。</li>","handler":"com.jap.controller.admin.ThirdLoginController.renderAuth","httpMethod":"GET","id":"com.jap.controller.admin.ThirdLoginController.renderAuth","module":"ThirdLoginController","params":[{"bindName":"socialStrategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.ThirdLoginController.socialStrategy","headerVariable":false,"httpMethod":"GET","name":"socialStrategy[Q]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"SocialStrategy"}],"path":"/social/getData","pathHtml":"/social/getData","port":8093,"scheme":"HTTP","xid":"GETcom_jap_controller_admin_ThirdLoginController_renderAuth"},{"controllerClass":"com.jap.controller.admin.ThirdLoginController","description":"准备策略：<br>\r\n----SocialStrategy：选择第三方应用 social验证策略，<a href=\"https://justauth.plus/quickstart/jap-social.html#%E6%B5%8B%E8%AF%95%E7%99%BB%E5%BD%95\">jap-social 是为了方便快速的集成第三方登录而添加的增强包</a>加入已经实现该策略验证方式的service具体类，这里是JapSocialUserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的缓存JapLocalCache：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存，\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n----注：在准备开始authenticate时，这里的demo是对SocialConfig保持默认的配置。<br>\r\n验证授权：<br>\r\n----social策略的验证方法是SocialStrategy的authenticate实现(参数是SocialConfig的上转型、HttpServletRequest、HttpServletResponse)，首先是先进行参数SocialConfig验证配置的初始化，配置检查，检查checkSessionAndCookie中有无此时登录的用户，如果存在，则说明登录成功（非首次登录），设置状态码200并返回响应<br>\r\n如果不存在(说明是第一次登录)，就先去调用getAuthRequest拿到AuthRequest对象（授权、登录接口）—--—实现方式————>，以SocialConfig对象的上转型AuthenticateConfig为参数，进行checkAuthenticateConfig检查配置完成且其子类socialConfig.getJustAuthConfig()非空后，<br>\r\n以第三方应用Platform平台（不能为空），socialConfig, authConfig，authStateCache为参数,去拿并返回AuthRequest实例（后面去授权、登录需要调用该实例接口）<br>\r\n参数准备：<br>\r\n<li>socialConfig：authenticate函数第一个参数转为子类SocialConfig对象</li>\r\n<li>source：从socialConfig拿到第三方平台名称</li>\r\n<li>authCallback（存有基本的授权参数）：把HttpServletRequest的所有参数转为Map集合（参数若为null，则new一个AuthCallback对象，否则遍历集合，进一步存入JSON对象中，由JSON的toJavaObject，拿到AuthCallback），</li>\r\n<br>\r\n判断是否已经回调isCallback(String source, AuthCallback authCallback) ：若默认第三方应用名字与参数source相同且authCallback的token非空，则返回TRUE，否则去authCallback拿到code值（这里需要特别判断一下授权码code是否是来源于ALIPAY或者HUAWEI），若code为空，返回TRUE<br>\r\n<li>isCallback返回值为FALSE：调用authRequest.authorize(socialConfig.getState())，返回JapResponse.success(url)，授权成功的响应，同意授权后URL中会带有生成的授权码code，再调用一次回调函数，进入该方法中，由code去拿到token</li>\r\n<li>isCallback返回值为TRUE：调用authRequest.login(request, response, source, authRequest, authCallback)————实现方式——---->实例化AuthResponse对象，用于存储后面通过token拿拿到用户信息的响应，由响应的用户ID和第三方平台名字为参数调用japUserService的getByPlatformAndUid去模拟数据库中查询用户信息，若不存在该用户则去调用japUserService的createAndGetSocialUser，都是把查询或者创建的用户存到JapUser对象中。此时已经登录成功，但需要把用户相关信息存入JapContext的UserStore（调用其接口实现，有单点登录Store和Session的Store存储）中。</li>","handler":"com.jap.controller.admin.ThirdLoginController.renderAuth","httpMethod":"POST","id":"com.jap.controller.admin.ThirdLoginController.renderAuth","module":"ThirdLoginController","params":[{"bindName":"socialStrategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.ThirdLoginController.socialStrategy","headerVariable":false,"httpMethod":"POST","name":"socialStrategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"SocialStrategy"}],"path":"/social/getData","pathHtml":"/social/getData","port":8093,"scheme":"HTTP","xid":"POSTcom_jap_controller_admin_ThirdLoginController_renderAuth"},{"controllerClass":"com.jap.controller.admin.ThirdLoginController","description":"准备策略：<br>\r\n----SocialStrategy：选择第三方应用 social验证策略，<a href=\"https://justauth.plus/quickstart/jap-social.html#%E6%B5%8B%E8%AF%95%E7%99%BB%E5%BD%95\">jap-social 是为了方便快速的集成第三方登录而添加的增强包</a>加入已经实现该策略验证方式的service具体类，这里是JapSocialUserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的缓存JapLocalCache：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存，\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n----注：在准备开始authenticate时，这里的demo是对SocialConfig保持默认的配置。<br>\r\n验证授权：<br>\r\n----social策略的验证方法是SocialStrategy的authenticate实现(参数是SocialConfig的上转型、HttpServletRequest、HttpServletResponse)，首先是先进行参数SocialConfig验证配置的初始化，配置检查，检查checkSessionAndCookie中有无此时登录的用户，如果存在，则说明登录成功（非首次登录），设置状态码200并返回响应<br>\r\n如果不存在(说明是第一次登录)，就先去调用getAuthRequest拿到AuthRequest对象（授权、登录接口）—--—实现方式————>，以SocialConfig对象的上转型AuthenticateConfig为参数，进行checkAuthenticateConfig检查配置完成且其子类socialConfig.getJustAuthConfig()非空后，<br>\r\n以第三方应用Platform平台（不能为空），socialConfig, authConfig，authStateCache为参数,去拿并返回AuthRequest实例（后面去授权、登录需要调用该实例接口）<br>\r\n参数准备：<br>\r\n<li>socialConfig：authenticate函数第一个参数转为子类SocialConfig对象</li>\r\n<li>source：从socialConfig拿到第三方平台名称</li>\r\n<li>authCallback（存有基本的授权参数）：把HttpServletRequest的所有参数转为Map集合（参数若为null，则new一个AuthCallback对象，否则遍历集合，进一步存入JSON对象中，由JSON的toJavaObject，拿到AuthCallback），</li>\r\n<br>\r\n判断是否已经回调isCallback(String source, AuthCallback authCallback) ：若默认第三方应用名字与参数source相同且authCallback的token非空，则返回TRUE，否则去authCallback拿到code值（这里需要特别判断一下授权码code是否是来源于ALIPAY或者HUAWEI），若code为空，返回TRUE<br>\r\n<li>isCallback返回值为FALSE：调用authRequest.authorize(socialConfig.getState())，返回JapResponse.success(url)，授权成功的响应，同意授权后URL中会带有生成的授权码code，再调用一次回调函数，进入该方法中，由code去拿到token</li>\r\n<li>isCallback返回值为TRUE：调用authRequest.login(request, response, source, authRequest, authCallback)————实现方式——---->实例化AuthResponse对象，用于存储后面通过token拿拿到用户信息的响应，由响应的用户ID和第三方平台名字为参数调用japUserService的getByPlatformAndUid去模拟数据库中查询用户信息，若不存在该用户则去调用japUserService的createAndGetSocialUser，都是把查询或者创建的用户存到JapUser对象中。此时已经登录成功，但需要把用户相关信息存入JapContext的UserStore（调用其接口实现，有单点登录Store和Session的Store存储）中。</li>","handler":"com.jap.controller.admin.ThirdLoginController.renderAuth","httpMethod":"DELETE","id":"com.jap.controller.admin.ThirdLoginController.renderAuth","module":"ThirdLoginController","params":[{"bindName":"socialStrategy","body":false,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.ThirdLoginController.socialStrategy","headerVariable":false,"httpMethod":"DELETE","name":"socialStrategy","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"Query parameter","type":"SocialStrategy"}],"path":"/social/getData","pathHtml":"/social/getData","port":8093,"scheme":"HTTP","xid":"DELETEcom_jap_controller_admin_ThirdLoginController_renderAuth"},{"controllerClass":"com.jap.controller.admin.ThirdLoginController","description":"准备策略：<br>\r\n----SocialStrategy：选择第三方应用 social验证策略，<a href=\"https://justauth.plus/quickstart/jap-social.html#%E6%B5%8B%E8%AF%95%E7%99%BB%E5%BD%95\">jap-social 是为了方便快速的集成第三方登录而添加的增强包</a>加入已经实现该策略验证方式的service具体类，这里是JapSocialUserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的缓存JapLocalCache：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存，\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n----注：在准备开始authenticate时，这里的demo是对SocialConfig保持默认的配置。<br>\r\n验证授权：<br>\r\n----social策略的验证方法是SocialStrategy的authenticate实现(参数是SocialConfig的上转型、HttpServletRequest、HttpServletResponse)，首先是先进行参数SocialConfig验证配置的初始化，配置检查，检查checkSessionAndCookie中有无此时登录的用户，如果存在，则说明登录成功（非首次登录），设置状态码200并返回响应<br>\r\n如果不存在(说明是第一次登录)，就先去调用getAuthRequest拿到AuthRequest对象（授权、登录接口）—--—实现方式————>，以SocialConfig对象的上转型AuthenticateConfig为参数，进行checkAuthenticateConfig检查配置完成且其子类socialConfig.getJustAuthConfig()非空后，<br>\r\n以第三方应用Platform平台（不能为空），socialConfig, authConfig，authStateCache为参数,去拿并返回AuthRequest实例（后面去授权、登录需要调用该实例接口）<br>\r\n参数准备：<br>\r\n<li>socialConfig：authenticate函数第一个参数转为子类SocialConfig对象</li>\r\n<li>source：从socialConfig拿到第三方平台名称</li>\r\n<li>authCallback（存有基本的授权参数）：把HttpServletRequest的所有参数转为Map集合（参数若为null，则new一个AuthCallback对象，否则遍历集合，进一步存入JSON对象中，由JSON的toJavaObject，拿到AuthCallback），</li>\r\n<br>\r\n判断是否已经回调isCallback(String source, AuthCallback authCallback) ：若默认第三方应用名字与参数source相同且authCallback的token非空，则返回TRUE，否则去authCallback拿到code值（这里需要特别判断一下授权码code是否是来源于ALIPAY或者HUAWEI），若code为空，返回TRUE<br>\r\n<li>isCallback返回值为FALSE：调用authRequest.authorize(socialConfig.getState())，返回JapResponse.success(url)，授权成功的响应，同意授权后URL中会带有生成的授权码code，再调用一次回调函数，进入该方法中，由code去拿到token</li>\r\n<li>isCallback返回值为TRUE：调用authRequest.login(request, response, source, authRequest, authCallback)————实现方式——---->实例化AuthResponse对象，用于存储后面通过token拿拿到用户信息的响应，由响应的用户ID和第三方平台名字为参数调用japUserService的getByPlatformAndUid去模拟数据库中查询用户信息，若不存在该用户则去调用japUserService的createAndGetSocialUser，都是把查询或者创建的用户存到JapUser对象中。此时已经登录成功，但需要把用户相关信息存入JapContext的UserStore（调用其接口实现，有单点登录Store和Session的Store存储）中。</li>","handler":"com.jap.controller.admin.ThirdLoginController.renderAuth","httpMethod":"PUT","id":"com.jap.controller.admin.ThirdLoginController.renderAuth","module":"ThirdLoginController","params":[{"bindName":"socialStrategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.ThirdLoginController.socialStrategy","headerVariable":false,"httpMethod":"PUT","name":"socialStrategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"SocialStrategy"}],"path":"/social/getData","pathHtml":"/social/getData","port":8093,"scheme":"HTTP","xid":"PUTcom_jap_controller_admin_ThirdLoginController_renderAuth"},{"controllerClass":"com.jap.controller.admin.ThirdLoginController","description":"准备策略：<br>\r\n----SocialStrategy：选择第三方应用 social验证策略，<a href=\"https://justauth.plus/quickstart/jap-social.html#%E6%B5%8B%E8%AF%95%E7%99%BB%E5%BD%95\">jap-social 是为了方便快速的集成第三方登录而添加的增强包</a>加入已经实现该策略验证方式的service具体类，这里是JapSocialUserServiceImpl,放进AbstractJapStrategy类(下一步认证需要使用），并初始化new config：用于设置是否是单点sso登录（默认为FALSE）、缓存和token有效时间，默认失效均时间为7天，AbstractJapStrategy中添加新的缓存JapLocalCache：单点登录——SsoJapUserStore缓存，否则SessionJapUserStore缓存，\r\n最终一并放进JapAuthentication.setContext(japUserStore,japCache,japConfig)的context。<br>\r\n----注：在准备开始authenticate时，这里的demo是对SocialConfig保持默认的配置。<br>\r\n验证授权：<br>\r\n----social策略的验证方法是SocialStrategy的authenticate实现(参数是SocialConfig的上转型、HttpServletRequest、HttpServletResponse)，首先是先进行参数SocialConfig验证配置的初始化，配置检查，检查checkSessionAndCookie中有无此时登录的用户，如果存在，则说明登录成功（非首次登录），设置状态码200并返回响应<br>\r\n如果不存在(说明是第一次登录)，就先去调用getAuthRequest拿到AuthRequest对象（授权、登录接口）—--—实现方式————>，以SocialConfig对象的上转型AuthenticateConfig为参数，进行checkAuthenticateConfig检查配置完成且其子类socialConfig.getJustAuthConfig()非空后，<br>\r\n以第三方应用Platform平台（不能为空），socialConfig, authConfig，authStateCache为参数,去拿并返回AuthRequest实例（后面去授权、登录需要调用该实例接口）<br>\r\n参数准备：<br>\r\n<li>socialConfig：authenticate函数第一个参数转为子类SocialConfig对象</li>\r\n<li>source：从socialConfig拿到第三方平台名称</li>\r\n<li>authCallback（存有基本的授权参数）：把HttpServletRequest的所有参数转为Map集合（参数若为null，则new一个AuthCallback对象，否则遍历集合，进一步存入JSON对象中，由JSON的toJavaObject，拿到AuthCallback），</li>\r\n<br>\r\n判断是否已经回调isCallback(String source, AuthCallback authCallback) ：若默认第三方应用名字与参数source相同且authCallback的token非空，则返回TRUE，否则去authCallback拿到code值（这里需要特别判断一下授权码code是否是来源于ALIPAY或者HUAWEI），若code为空，返回TRUE<br>\r\n<li>isCallback返回值为FALSE：调用authRequest.authorize(socialConfig.getState())，返回JapResponse.success(url)，授权成功的响应，同意授权后URL中会带有生成的授权码code，再调用一次回调函数，进入该方法中，由code去拿到token</li>\r\n<li>isCallback返回值为TRUE：调用authRequest.login(request, response, source, authRequest, authCallback)————实现方式——---->实例化AuthResponse对象，用于存储后面通过token拿拿到用户信息的响应，由响应的用户ID和第三方平台名字为参数调用japUserService的getByPlatformAndUid去模拟数据库中查询用户信息，若不存在该用户则去调用japUserService的createAndGetSocialUser，都是把查询或者创建的用户存到JapUser对象中。此时已经登录成功，但需要把用户相关信息存入JapContext的UserStore（调用其接口实现，有单点登录Store和Session的Store存储）中。</li>","handler":"com.jap.controller.admin.ThirdLoginController.renderAuth","httpMethod":"PATCH","id":"com.jap.controller.admin.ThirdLoginController.renderAuth","module":"ThirdLoginController","params":[{"bindName":"socialStrategy","body":true,"defaultValue":"","description":"","fieldKey":"com.jap.controller.admin.ThirdLoginController.socialStrategy","headerVariable":false,"httpMethod":"PATCH","name":"socialStrategy[B]","pathVar":false,"required":false,"sessionVariable":false,"tooltip":"JSON body or post form field","type":"SocialStrategy"}],"path":"/social/getData","pathHtml":"/social/getData","port":8093,"scheme":"HTTP","xid":"PATCHcom_jap_controller_admin_ThirdLoginController_renderAuth"}]}